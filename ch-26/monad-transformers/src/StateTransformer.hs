module StateTransformer where

import Data.Bifunctor
import Data.Functor.Identity    

newtype StateT s m a =
    StateT {
        -- "runStateT" is a field accessor. 
        -- It is not explicitly implemented since it is generated by the "StateT" newtype. 
        -- It has the type: 
        -- runStateT :: StateT s m a -> s -> m (a,s) 
        runStateT :: s -> m (a,s)
    }

-- ghci> import Data.Functor.Identity    
-- ghci> let stateTFunc = StateT ( Identity . (True,) ) 
-- ghci> runStateT stateTFunc 5

-- Example making a StateT with Identity monad and an initial state of 5
myStateT :: Identity (Int, Int)
myStateT  = 
   runStateT mkStateT 5
    where 
        mkStateT :: StateT Int Identity Int
        mkStateT =  StateT (\st -> Identity (st , st + 1))     



-- ================================ Functor ======================================== -- 

instance (Functor m) => Functor (StateT s m)
    where
        fmap :: Functor m => (a -> b) -> StateT s m a -> StateT s m b
        fmap f (StateT m) = 
            let stateTFunc = fmap (first f) . m
                   -- (\s -> fmap (first f) (m s))
                   -- (\s -> fmap (\(a, b) -> (f a, b)) (m s))
            in StateT stateTFunc
                        
-- Example using <$> with StateT and Identity monad and an initial state of 5
myStateTFunctor :: Identity (String, Int)
myStateTFunctor = 
    runStateT (fmap (++ ", curr: ") mkStateT) 5    
        where 
            mkStateT :: StateT Int Identity String
            mkStateT =  StateT (\st -> Identity ("prev: " ++ show st , st + 1))     

-- ================================ Applicative ======================================== -- 

instance (Monad m) => Applicative (StateT s m) 
    where 
        pure :: Monad m => a -> StateT s m a
        pure a =  StateT $ \s -> return (a,s)
        
        (<*>) :: Monad m => StateT s m (a -> b) -> StateT s m a -> StateT s m b
        (<*>) (StateT sf) (StateT sm) =                 
                -- StateT (\s ->  
                --     (sf s) >>= (\abs ->
                --         sm (snd abs) >>= \as ->   
                --             pure ((fst abs $ fst as) , (snd as) )
                --     )
                -- )
                StateT (\s -> do
                    abs <- sf s
                    as  <- sm (snd abs)
                    pure ((fst abs) (fst as) , snd as)

                )

-- Example using <*> with StateT and Identity monad and an initial state of 5
myStateTApplicative :: (Int, Int)
myStateTApplicative = 
    runIdentity $ runStateT mkStateT 3
        where 
            mkStateT :: StateT Int Identity Int
            mkStateT = (+) 
                <$> StateT (\s -> Identity (10, s+1)) 
                <*> StateT (\s' -> Identity (10, s'+1))

-- ================================ Monad ======================================== -- 

instance (Monad m) => Monad (StateT s m) 
    where
        return :: Monad m => a -> StateT s m a
        return = pure
        
        (>>=) :: Monad m => StateT s m a -> (a -> StateT s m b) -> StateT s m b
        (>>=) (StateT sma) f = 
            StateT (\s -> do 
                ma <- sma s                
                runStateT (f $ fst ma) (snd ma)                
            )

-- Example using >>= with StateT and Identity monad and an initial state of 5
myStateTMonad :: (Int, Int)
myStateTMonad = 
    runIdentity $ runStateT mkStateT 3
        where
            mkStateT :: StateT Int Identity Int
            mkStateT =  
                StateT (\s -> Identity (s + 1, s+1))
                    >>= \s' ->
                        StateT (\s -> Identity (s' * 5, s'+1))
            